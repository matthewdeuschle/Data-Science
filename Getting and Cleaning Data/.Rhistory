x
mergedData = merge(eduSubset,gdpSubset,by.x="CountryCode",by.y="X",all=FALSE)  # match eduSubset and gdpSubset based on 'CountryCode' & 'gdp' columns respectively; FALSE indicate that only
# those rows that match in both datasets
mergedData$X.3 = as.numeric(as.character(mergedData))
gdp = read.csv("./Week 3/getdata-data-GDP.csv")
edu = read.csv("./Week 3/getdata-data-EDSTATS_Country.csv")
eduSubset = edu[,c("CountryCode","Income.Group","Long.Name")]  # retrieve 'CountryCode' & 'Income.Group' columns from edu dataset
gdpSubset = gdp[(!gdp$X.3 %in% c("..","(millions of", "US dollars)","")),c("X","X.3")] # from gdp dataset return those observations where the values in 'X.3' column doesn't
# belong to any of these values - c("..","(millions of", "US dollars)",""). Furthermore, only return
# 'X' & 'X.3' columns from the resulting dataset
mergedData = merge(eduSubset,gdpSubset,by.x="CountryCode",by.y="X",all=FALSE)  # match eduSubset and gdpSubset based on 'CountryCode' & 'gdp' columns respectively; FALSE indicate that only
# those rows that match in both datasets
mergedData$X.3 = as.numeric(as.character(mergedData))
gdp = read.csv("./Week 3/getdata-data-GDP.csv")
edu = read.csv("./Week 3/getdata-data-EDSTATS_Country.csv")
eduSubset = edu[,c("CountryCode","Income.Group","Long.Name")]  # retrieve 'CountryCode' & 'Income.Group' columns from edu dataset
gdpSubset = gdp[(!gdp$X.3 %in% c("..","(millions of", "US dollars)","")),c("X","X.3")] # from gdp dataset return those observations where the values in 'X.3' column doesn't
# belong to any of these values - c("..","(millions of", "US dollars)",""). Furthermore, only return
# 'X' & 'X.3' columns from the resulting dataset
mergedData = merge(eduSubset,gdpSubset,by.x="CountryCode",by.y="X",all=FALSE)  # match eduSubset and gdpSubset based on 'CountryCode' & 'gdp' columns respectively; FALSE indicate that only
# those rows that match in both datasets
mergedData$X.3 = as.numeric(as.character(mergedData$X.3))
mergedData$X.3
gdp = read.csv("./Week 3/getdata-data-GDP.csv")
edu = read.csv("./Week 3/getdata-data-EDSTATS_Country.csv")
eduSubset = edu[,c("CountryCode","Income.Group","Long.Name")]  # retrieve 'CountryCode' & 'Income.Group' columns from edu dataset
gdpSubset = gdp[(!gdp$X.3 %in% c("..","(millions of", "US dollars)","")),c("X","X.3")] # from gdp dataset return those observations where the values in 'X.3' column doesn't
# belong to any of these values - c("..","(millions of", "US dollars)",""). Furthermore, only return
# 'X' & 'X.3' columns from the resulting dataset
mergedData = merge(eduSubset,gdpSubset,by.x="CountryCode",by.y="X",all=FALSE)  # match eduSubset and gdpSubset based on 'CountryCode' & 'gdp' columns respectively; FALSE indicate that only
# those rows that match in both datasets
mergedData$X.3
levels(mergedData$X.3)
mergedData$X.3 = factor(mergedData$X.3)
levels(mergedData$X.3)
gdp = read.csv("./Week 3/getdata-data-GDP.csv")
edu = read.csv("./Week 3/getdata-data-EDSTATS_Country.csv")
eduSubset = edu[,c("CountryCode","Income.Group","Long.Name")]  # retrieve 'CountryCode' & 'Income.Group' columns from edu dataset
gdpSubset = gdp[(!gdp$X.3 %in% c("..","(millions of", "US dollars)","")),c("X","X.3")] # from gdp dataset return those observations where the values in 'X.3' column doesn't
# belong to any of these values - c("..","(millions of", "US dollars)",""). Furthermore, only return
# 'X' & 'X.3' columns from the resulting dataset
mergedData = merge(eduSubset,gdpSubset,by.x="CountryCode",by.y="X",all=FALSE)  # match eduSubset and gdpSubset based on 'CountryCode' & 'gdp' columns respectively; FALSE indicate that only
# those rows that match in both datasets
levels(mergedData$X.3)
mergedData$X.3 = factor(mergedData$X.3)
levels(mergedData$X.3)
mergedData$X.3 = as.numeric(as.character(mergedData$X.3))
mergedData$X.3
gdp = read.csv("./Week 3/getdata-data-GDP.csv")
edu = read.csv("./Week 3/getdata-data-EDSTATS_Country.csv")
eduSubset = edu[,c("CountryCode","Income.Group","Long.Name")]  # retrieve 'CountryCode' & 'Income.Group' columns from edu dataset
gdpSubset = gdp[(!gdp$X.3 %in% c("..","(millions of", "US dollars)","")),c("X","X.3")] # from gdp dataset return those observations where the values in 'X.3' column doesn't
# belong to any of these values - c("..","(millions of", "US dollars)",""). Furthermore, only return
# 'X' & 'X.3' columns from the resulting dataset
mergedData = merge(eduSubset,gdpSubset,by.x="CountryCode",by.y="X",all=FALSE)  # match eduSubset and gdpSubset based on 'CountryCode' & 'gdp' columns respectively; FALSE indicate that only
# those rows that match in both datasets
mergedData$X.3 = factor(mergedData$X.3)
mergedData$X.3
as.numeric(mergedData$X.3)
as.character(mergedData$X.3)
df <- data.frame(letters=letters[1:5],
numbers=seq(1:5))
subdf <- subset(df, numbers <= 3)
levels(df$letters)
blah<-c("4","8","10","15")
blah.new<-as.factor(blah)
blah.new1<-as.numeric(blah.new)
blah.new1
blah
blah.new1<-as.numeric(as.character(blah.new))
blah.new1
blah<-c(" 4 "," 8 "," 10 "," 15 ")
blah.new<-as.factor(blah)
blah.new1<-as.numeric(as.character(blah.new))
blah.new1
blah<-c(" 4 ","72,440,449"," 10 "," 15 ")
blah.new<-as.factor(blah)
blah.new1<-as.numeric(as.character(blah.new))
blah.new1
trim <- function (x) gsub("^\\s+|\\s+$", "", x)
blah<-c(" 4 ","72,440,449"," 10 "," 15 ")
blah.new<-as.factor(blah)
blah.new1<-as.numeric(as.character(trim(blah.new))
blah.new1
trim <- function (x) gsub("^\\s+|\\s+$", "", x)
blah<-c(" 4 ","72,440,449"," 10 "," 15 ")
blah.new<-as.factor(blah)
blah.new1<-as.numeric(as.character(trim(blah.new)))
blah.new1
blah<-c(" 4 ","72,440,449"," 10 "," 15 ")
blah.new<-as.factor(blah)
blah.new
trim(as.character(blah.new))
trim <- function (x)
gsub(",+","",gsub("^\\s+|\\s+$", "", x))
}
{
blah<-c(" 4 ","72,440,449"," 10 "," 15 ")
blah.new<-as.factor(blah)
blah.new
trim(as.character(blah.new))
blah.new1<-as.numeric(as.character(trim(blah.new)))
blah.new1
mergedData$X.3
trim <- function (x)
{
gsub(",+","",gsub("^\\s+|\\s+$", "", x))
}
blah<-c(" 4 ","72,440,449"," 10 "," 15 ")
blah.new<-as.factor(blah)
blah.new
trim(as.character(blah.new))
blah.new1<-as.numeric(trim(as.character(blah.new)))
blah.new1
gdp = read.csv("./Week 3/getdata-data-GDP.csv")
edu = read.csv("./Week 3/getdata-data-EDSTATS_Country.csv")
eduSubset = edu[,c("CountryCode","Income.Group","Long.Name")]  # retrieve 'CountryCode' & 'Income.Group' columns from edu dataset
gdpSubset = gdp[(!gdp$X.3 %in% c("..","(millions of", "US dollars)","")),c("X","X.3")] # from gdp dataset return those observations where the values in 'X.3' column doesn't
# belong to any of these values - c("..","(millions of", "US dollars)",""). Furthermore, only return
# 'X' & 'X.3' columns from the resulting dataset
mergedData = merge(eduSubset,gdpSubset,by.x="CountryCode",by.y="X",all=FALSE)  # match eduSubset and gdpSubset based on 'CountryCode' & 'gdp' columns respectively; FALSE indicate that only
# those rows that match in both datasets
formatLevel <- function (x)   # function to format the level as it contains unwanted characters : , " "
{
gsub(",+","",gsub("^\\s+|\\s+$", "", x))
}
mergedData$X.3 = factor(mergedData$X.3)
mergedData$X.3 = as.numeric(formateLevel(as.character(mergedData$X.3)))
mergedData$X.3 = as.numeric(formatLevel(as.character(mergedData$X.3)))
mergedData$X.3
str(mergedData$X.3)
arrange(mergedData, desc(mergedData$X.3))  # sort the 'mergedData' dataset by decreasing GDP rank
gdp$Gross.domestic.product.2012
str(gdp$Gross.domestic.product.2012)
grep("[0-9]+",gdp$Gross.domestic.product.2012, perl=TRUE)
dim(grep("[0-9]+",gdp$Gross.domestic.product.2012, perl=TRUE))
length(grep("[0-9]+",gdp$Gross.domestic.product.2012, perl=TRUE))
grep("[0-9]+",gdp$Gross.domestic.product.2012, perl=TRUE, Value=TRUE)
grep("[0-9]+",gdp$Gross.domestic.product.2012, perl=TRUE, value=TRUE)
grep("^[0-9]+$",gdp$Gross.domestic.product.2012, perl=TRUE, value=TRUE)
grep("^[0-9]+$",gdp$Gross.domestic.product.2012, perl=TRUE, value=FALSE)
gdpSubset = gdp[grep("^[0-9]+$",gdp$Gross.domestic.product.2012, perl=TRUE, value=FALSE),c("X","X.3")]
gdp = read.csv("./Week 3/getdata-data-GDP.csv")
edu = read.csv("./Week 3/getdata-data-EDSTATS_Country.csv")
eduSubset = edu[,c("CountryCode","Income.Group","Long.Name")]  # retrieve 'CountryCode' & 'Income.Group' columns from edu dataset
# gdpSubset = gdp[(!gdp$X.3 %in% c("..","(millions of", "US dollars)","")),c("X","X.3")] # from gdp dataset return those observations where the values in 'X.3' column doesn't
#                                                                                        # belong to any of these values - c("..","(millions of", "US dollars)",""). Furthermore, only return
#                                                                                        # 'X' & 'X.3' columns from the resulting dataset
gdpSubset = gdp[grep("^[0-9]+$",gdp$Gross.domestic.product.2012, perl=TRUE, value=FALSE),c("X","X.3")]
mergedData = merge(eduSubset,gdpSubset,by.x="CountryCode",by.y="X",all=FALSE)  # match eduSubset and gdpSubset based on 'CountryCode' & 'gdp' columns respectively; FALSE indicate that only
# those rows that match in both datasets
mergedData$X.3 = factor(mergedData$X.3)  # Since the unwanted levels where removed in the above, update the dataset 'mergedData' using the factor function
formatLevel <- function (x)   # function to format the level as it contains unwanted characters : , " "
{
gsub(",+","",gsub("^\\s+|\\s+$", "", x))
}
mergedData$X.3 = as.numeric(formatLevel(as.character(mergedData$X.3))) # Convert all of the factors into numeric.
sorted = arrange(mergedData, desc(mergedData$X.3))  # sort the 'mergedData' dataset by decreasing GDP rank
View(sorted)
View(sorted)
sorted = arrange(mergedData, asc(mergedData$X.3))  # sort the 'mergedData' dataset by decreasing GDP rank
View(sorted)
View(sorted)
sorted = arrange(mergedData, asc(mergedData$X.3))  # sort the 'mergedData' dataset by decreasing GDP rank
mergedData[order(-X.3),]
mergedData[order(-mergedData$X.3),]
mergedData[order(mergedData$X.3),]
mergedData[order(mergedData$X.3),][13,]
gdp = read.csv("./Week 3/getdata-data-GDP.csv")
edu = read.csv("./Week 3/getdata-data-EDSTATS_Country.csv")
eduSubset = edu[,c("CountryCode","Income.Group","Long.Name")]  # retrieve 'CountryCode' & 'Income.Group' columns from edu dataset
# gdpSubset = gdp[(!gdp$X.3 %in% c("..","(millions of", "US dollars)","")),c("X","X.3")] # from gdp dataset return those observations where the values in 'X.3' column doesn't
#                                                                                        # belong to any of these values - c("..","(millions of", "US dollars)",""). Furthermore, only return
#                                                                                        # 'X' & 'X.3' columns from the resulting dataset
gdpSubset = gdp[grep("^[0-9]+$",gdp$Gross.domestic.product.2012, perl=TRUE, value=FALSE),c("X","X.3","Gross.domestic.product.2012")]
mergedData = merge(eduSubset,gdpSubset,by.x="CountryCode",by.y="X",all=FALSE)  # match eduSubset and gdpSubset based on 'CountryCode' & 'gdp' columns respectively; FALSE indicate that only
# those rows that match in both datasets
mergedData$Gross.domestic.product.2012
levels(mergedData$Gross.domestic.product.2012)
mergedData$Gross.domestic.product.2012 = factor(mergedData$Gross.domestic.product.2012)  # Since the unwanted levels where removed in the above, update the dataset 'mergedData' using the factor function
levels(mergedData$Gross.domestic.product.2012)
names(gdpSubset)
names(gdpSubset$Gross.domestic.product.2012)
names(gdpSubset)[3]
gdp = read.csv("./Week 3/getdata-data-GDP.csv")
edu = read.csv("./Week 3/getdata-data-EDSTATS_Country.csv")
eduSubset = edu[,c("CountryCode","Income.Group","Long.Name")]  # retrieve 'CountryCode' & 'Income.Group' columns from edu dataset
# gdpSubset = gdp[(!gdp$X.3 %in% c("..","(millions of", "US dollars)","")),c("X","X.3")] # from gdp dataset return those observations where the values in 'X.3' column doesn't
#                                                                                        # belong to any of these values - c("..","(millions of", "US dollars)",""). Furthermore, only return
#                                                                                        # 'X' & 'X.3' columns from the resulting dataset
gdpSubset = gdp[grep("^[0-9]+$",gdp$Gross.domestic.product.2012, perl=TRUE, value=FALSE),c("X","X.3","Gross.domestic.product.2012")]
names(gdpSubset)[3] = "Ranking" # Rename column for usability
mergedData = merge(eduSubset,gdpSubset,by.x="CountryCode",by.y="X",all=FALSE)  # match eduSubset and gdpSubset based on 'CountryCode' & 'gdp' columns respectively; FALSE indicate that only
# those rows that match in both datasets
levels(mergedData$Ranking)
mergedData$Ranking = factor(mergedData$Ranking)  # Since the unwanted levels where removed in the above, update the dataset 'mergedData' using the factor function
levels(mergedData$Ranking)
formatLevel <- function (x)   # function to format the level as it contains unwanted characters : , " "
{
gsub(",+","",gsub("^\\s+|\\s+$", "", x))
}
mergedData$Ranking = as.numeric(formatLevel(as.character(mergedData$Ranking))) # Convert all of the factors into numeric.
mergedData[order(mergedData$Ranking),][13,]   # sort the 'mergedData' dataset by decreasing GDP rank
mergedData$Ranking = as.numeric(formatLevel(as.character(mergedData$Ranking))) # Convert all of the factors into numeric.
mergedData[order(mergedData$Ranking),]   # sort the 'mergedData' dataset by decreasing GDP rank
mergedData[order(-mergedData$Ranking),]   # sort the 'mergedData' dataset by decreasing GDP rank
mergedData[order(-mergedData$Ranking),][13,]   # sort the 'mergedData' dataset by decreasing GDP rank
mergedData[order(-mergedData$Ranking),][0,]   # sort the 'mergedData' dataset by decreasing GDP rank
mergedData = merge(eduSubset,gdpSubset,by.x="CountryCode",by.y="X",all=TRUE)  # match eduSubset and gdpSubset based on 'CountryCode' & 'gdp' columns respectively; FALSE indicate that only
# those rows that match in both datasets
levels(mergedData$Ranking)
mergedData$Ranking = factor(mergedData$Ranking)  # Since the unwanted levels where removed in the above, update the dataset 'mergedData' using the factor function
formatLevel <- function (x)   # function to format the level as it contains unwanted characters : , " "
{
gsub(",+","",gsub("^\\s+|\\s+$", "", x))
}
mergedData$Ranking = as.numeric(formatLevel(as.character(mergedData$Ranking))) # Convert all of the factors into numeric.
mergedData[order(-mergedData$Ranking),][1,]   # sort the 'mergedData' dataset by decreasing GDP rank
mergedData[order(-mergedData$Ranking),][13,]   # sort the 'mergedData' dataset by decreasing GDP rank
gdpSubset = gdp[grep("^[0-9]+$",gdp$Gross.domestic.product.2012, perl=TRUE, value=FALSE),c("X","X.3","Gross.domestic.product.2012")]
names(gdpSubset)[3] = "Ranking" # Rename column for usability
mergedData = merge(eduSubset,gdpSubset,by.x="CountryCode",by.y="X",all=FALSE)  # match eduSubset and gdpSubset based on 'CountryCode' & 'gdp' columns respectively; FALSE indicate that only
View(eduSubset)
View(eduSubset)
View(gdpSubset)
View(gdpSubset)
mergedData = merge(gdpSubset,eduSubset,by.x="CountryCode",by.y="X",all=FALSE)  # match eduSubset and gdpSubset based on 'CountryCode' & 'gdp' columns respectively; FALSE indicate that only
mergedData = merge(gdpSubset,eduSubset,by.x="X",by.y="CountryCode",all=FALSE)  # match eduSubset and gdpSubset based on 'CountryCode' & 'gdp' columns respectively; FALSE indicate that only
mergeData$CountryCode
mergedData$CountryCode
mergedData = merge(gdpSubset,eduSubset,by.x="X",by.y="CountryCode",all=FALSE)  # match eduSubset and gdpSubset based on 'CountryCode' & 'gdp' columns respectively; FALSE indicate that only
# those rows that match in both datasets
View(mergedData)
View(mergedData)
mergedData[order(-mergedData$Ranking),]
gdp = read.csv("./Week 3/getdata-data-GDP.csv")
edu = read.csv("./Week 3/getdata-data-EDSTATS_Country.csv")
eduSubset = edu[,c("CountryCode","Income.Group","Long.Name")]  # retrieve 'CountryCode' & 'Income.Group' columns from edu dataset
#                                                                                        # belong to any of these values - c("..","(millions of", "US dollars)",""). Furthermore, only return
# gdpSubset = gdp[(!gdp$X.3 %in% c("..","(millions of", "US dollars)","")),c("X","X.3")] # from gdp dataset return those observations where the values in 'X.3' column doesn't
#                                                                                        # 'X' & 'X.3' columns from the resulting dataset
gdpSubset = gdp[grep("^[0-9]+$",gdp$Gross.domestic.product.2012, perl=TRUE, value=FALSE),c("X","X.3","Gross.domestic.product.2012")]
names(gdpSubset)[3] = "Ranking" # Rename column for usability
mergedData = merge(gdpSubset,eduSubset,by.x="X",by.y="CountryCode",all=FALSE)  # match eduSubset and gdpSubset based on 'CountryCode' & 'gdp' columns respectively; FALSE indicate that only
# those rows that match in both datasets
# mergedData[order(-mergedData$Ranking),]
#
# levels(mergedData$Ranking)
mergedData$Ranking = factor(mergedData$Ranking)  # Since the unwanted levels where removed in the above, update the dataset 'mergedData' using the factor function
formatLevel <- function (x)   # function to format the level as it contains unwanted characters : , " "
gsub(",+","",gsub("^\\s+|\\s+$", "", x))
{
}
mergedData$Ranking = as.numeric(formatLevel(as.character(mergedData$Ranking))) # Convert all of the factors into numeric.
mergedData[order(-mergedData$Ranking),][13,]   # sort the 'mergedData' dataset by decreasing GDP rank
mergedData[order(-mergedData$Ranking),]   # sort the 'mergedData' dataset by decreasing GDP rank
mergedData[order(mergedData$Ranking),]   # sort the 'mergedData' dataset by decreasing GDP rank
gdp = read.csv("./Week 3/getdata-data-GDP.csv")
names(gdp)
edu[which(edu$Income.Group == "High income: OECD"),]
mergedData[which(mergedData$Income.Group == "High income: OECD"),]
x = mean(mergedData[which(mergedData$Income.Group == "High income: OECD"),c("Ranking")])
y = mean(mergedData[which(mergedData$Income.Group == "High income: nonOECD"),c("Ranking")])
q = quantile(mergedData$Ranking, n=5) # quantiles for the zipCode; we'll use this group the zipCodes
q = quantile(mergedData$Ranking) # quantiles for the zipCode; we'll use this group the zipCodes
q
table(cut(mergedData$Ranking, breaks=q))  # cuts the mergedData into groups;  (0%  25%  50%  75% 100%
table(cut(mergedData$Ranking, breaks=q), mergedData$Income.Group)  # cuts the mergedData into groups;  (0%  25%  50%  75% 100%
g = table(cut(mergedData$Ranking, breaks=q), mergedData$Income.Group)  # cuts the mergedData into groups;  (0%  25%  50%  75% 100%
table(mergedData$Income.Group)
mergedData = mergedData[order(mergedData$Ranking),]
q = quantile(mergedData$Ranking) # quantiles for the Ranking; we'll use this group the mergedData
q
g = table(cut(mergedData$Ranking, breaks=q), mergedData$Income.Group)  # cuts the mergedData into groups;  (0%  25%  50%  75% 100%
g
mergedData = mergedData[order(mergedData$Ranking),]
mergedData
mergedData
q = quantile(mergedData$Ranking) # quantiles for the Ranking; we'll use this group the mergedData
q
g = table(cut(mergedData$Ranking, breaks=q), mergedData$Income.Group)  # cuts the mergedData into groups;  (0%  25%  50%  75% 100%
#                                     1   48   95  143  190  )
g
mergedData = mergedData[order(-mergedData$Ranking),]
mergedData
q = quantile(mergedData$Ranking) # quantiles for the Ranking; we'll use this group the mergedData
q
g = table(cut(mergedData$Ranking, breaks=q), mergedData$Income.Group)  # cuts the mergedData into groups;  (0%  25%  50%  75% 100%
#                                     1   48   95  143  190  )
g
q = quantile(mergedData$Ranking, probs=c(1,2,3,4,5)) # quantiles for the Ranking; we'll use this group the mergedData
q
q = quantile(mergedData$Ranking, c(1,2,3,4,5)) # quantiles for the Ranking; we'll use this group the mergedData
q = quantile(mergedData$Ranking, c(0.38,0.5,0.75,0.80,1)) # quantiles for the Ranking; we'll use this group the mergedData
q
q = quantile(mergedData$Ranking, c(0, 0.38,0.5,0.75,0.80)) # quantiles for the Ranking; we'll use this group the mergedData
q
g = table(cut(mergedData$Ranking, breaks=q), mergedData$Income.Group)  # cuts the mergedData into groups;  (0%  25%  50%  75% 100%
#                                     1   48   95  143  190  )
g
q = quantile(mergedData$Ranking, c(0, 0.2,0.5,0.75,0.80)) # quantiles for the Ranking; we'll use this group the mergedData
q
g = table(cut(mergedData$Ranking, breaks=q), mergedData$Income.Group)  # cuts the mergedData into groups;  (0%  25%  50%  75% 100%
#                                     1   48   95  143  190  )
g
merged$gr = cut2(mergedData$Ranking,g=5)
table(merged$gr,merged$Income.Group))
mergedData$gr = cut2(mergedData$Ranking,g=5)
table(mergedData$gr,mergedData$Income.Group))
table(mergedData$gr,mergedData$Income.Group)
mergedData = mergedData[order(mergedData$Ranking),]
mergedData$gr = cut2(mergedData$Ranking,g=5)
table(mergedData$gr,mergedData$Income.Group)
mergedData = mergedData[order(-mergedData$Ranking),]
mergedData
mergedData$gr = cut2(mergedData$Ranking,g=5)
table(mergedData$gr,mergedData$Income.Group)
q = quantile(mergedData$Ranking, c(0, 0.2,0.5,0.75,0.80)) # quantiles for the Ranking; we'll use this group the mergedData. I selec
q
g = table(cut(mergedData$Ranking, breaks=q), mergedData$Income.Group)  # cuts the mergedData into groups;  (0%  25%  50%  75% 100%
#                                     1   48   95  143  190  )
g
q = quantile(mergedData$Ranking, c(0, 0.2,0.5,0.75,0.80)) # quantiles for the Ranking; we'll use this group the mergedData. I selected these prob - 0, 0.2,0.5,0.75,0.80 b/c
# in finding the top 38 high ranking countries. Using those probs gave me these groups - 1.0  38.6  95.0 143.0 152.4
table(cut(mergedData$Ranking, breaks=q), mergedData$Income.Group)  # cuts the mergedData into groups;  1.0  38.6  95.0 143.0 152.4 and further group them by income.groups
mergedData = mergedData[order(-mergedData$Ranking),]
q = quantile(mergedData$Ranking, c(0, 0.2,0.5,0.75,0.80)) # quantiles for the Ranking; we'll use this group the mergedData. I selected these prob - 0, 0.2,0.5,0.75,0.80 b/c
# in finding the top 38 high ranking countries. Using those probs gave me these groups - 1.0  38.6  95.0 143.0 152.4
table(cut(mergedData$Ranking, breaks=q), mergedData$Income.Group)  # cuts the mergedData into groups;  1.0  38.6  95.0 143.0 152.4 and further group them by income.groups
mergedData = mergedData[order(mergedData$Ranking),]
q = quantile(mergedData$Ranking, c(0, 0.2,0.5,0.75,0.80)) # quantiles for the Ranking; we'll use this group the mergedData. I selected these prob - 0, 0.2,0.5,0.75,0.80 b/c
# in finding the top 38 high ranking countries. Using those probs gave me these groups - 1.0  38.6  95.0 143.0 152.4
table(cut(mergedData$Ranking, breaks=q), mergedData$Income.Group)  # cuts the mergedData into groups;  1.0  38.6  95.0 143.0 152.4 and further group them by income.groups
getwd()
getwd()
restData = read.csv("./Week 3/restaurants.csv")
list.files(getwd())
list.files(getwd())
k = paste(getwd(), "/Week 4/", sep=" ")
list.files(k)
getwd()
setwd("F:/My Development/My Testing Ground/Data Science/Data Science Cert - Code/Getting and Cleaning Data/Week 3")
setwd("F:/My Development/My Testing Ground/Data Science/Data Science Cert - Code/Getting and Cleaning Data/Week 3")
getwd()
list.files()
fileUrl1 = "https://dl.dropboxusercontent.com/u/7710864/data/reviews-apr29.csv"
fileUrl2 = "https://dl.dropboxusercontent.com/u/7710864/data/solutions-apr29.csv"
gwd()
getwd()
download.file(file.Url1,destfile="./data/reviews.csv",method="curl")
download.file(fileUrl1,destfile="./Week 4/reviews.csv",method="curl")
reviews = read.csv("./data/reviews.csv");
reviews = read.csv("./Week 4/reviews.csv");
getwd()
reviews = read.csv("./Week 4/reviews.csv");
solutions = read.csv("./Week 4/solutions.csv");
head(reviews, 2)
head(solutions, 2)
names(reviews)
sub{"_","",names(reviews),}
sub("_","",names(reviews),)
names(reviews)
sub("_","",names(reviews),)
testName = "this_is_a_test"
sub("_","",testName)
gsub("_","",testName)
library("stringr", lib.loc="C:/Users/dormantroot/Documents/R/win-library/3.0")
nchar("Jeffrey Leek")
substr("Jeffrey Leek",1,7)
paste("Jeffery","Leek")
paste("Jeffery","Leek", sep="")
date()
class(date())
class(Sys.Date())
d2 = Sys.Date()
format(d2, "%a %b %d")
z = as.Date(x, "%d%b%Y")
x = c("1jan1960","2jan1960","31mar1960","30jul1960");
z = as.Date(x, "%d%b%Y")
z
z[1] - z[2]
survey = read.csv("./Week 4/american_community_survey.csv");
names(survey)
strsplit("this_is_africa","_")
splitNames = strsplit(names(survey), "wgtp")
splitNames[188]
splitNames[123]
rank = read.csv("./Week 4/gross_domestic_product_rank.csv");
names(rank)
summary(rank)
head(rank,3)
head(rank,10)
rank$X.3
rank$X.3
gdpSubset = rank[grep("^[0-9]+$",rank$Gross.domestic.product.2012, perl=TRUE,
value=FALSE),c("X","X.3","Gross.domestic.product.2012")] # find those obs from gdp where the ranking is from # 1 to 190
value=FALSE),c("X","X.3","Gross.domestic.product.2012")] # find those obs from gdp where the ranking is from # 1 to 190
gdpSubset
gdpSubset$x.3
names(gdpSubset)
gdpSubset$x.3
gdpSubset$X.3
formatLevel <- function (x)   # function to format the level as it contains unwanted characters : , " "
{
gsub(",+","",gsub("^\\s+|\\s+$", "", x))
}
gdpSubset$X.3 = as.numeric(formatLevel(as.character(gdpSubset$X.3))) # Convert all of the factors into numeric.
gdpSubset$X.3
summary(gdpSubset$X.3)
rank = read.csv("./Week 4/gross_domestic_product_rank.csv");
head(rank,10)
rank[,c(2,5)]
formatLevel <- function (x)   # function to format the level as it contains unwanted characters : , " "
{
gsub(",+","",gsub("^\\s+|\\s+$", "", x))
}
rank$X.3 = formatLevel(as.character(rank$X.3)) # remove all comma & space from values in column X.3
rank = read.csv("./Week 4/gross_domestic_product_rank.csv");
head(rank,10)
rank[,c(2,5)]
formatValue <- function (x)   # function to format values that contain unwanted characters : , " "
{
gsub(",+","",gsub("^\\s+|\\s+$", "", x))
}
rank$X.3 = formatValue(as.character(rank$X.3)) # remove all comma & space from values in column X.3
rank[,c(2,5)]
gdpSubset = rank[grep("^[0-9]+$",rank$X.3, perl=TRUE,
value=FALSE),c("X","X.3","Gross.domestic.product.2012")] # find those obs where value in column X.3 is numeric
gdpSubset[,c(2,3)]
gdpSubset$X.3 = as.numeric(gdpSubset$X.3) # Convert all of the factors into numeric.
summary(gdpSubset$X.3)
average(gdpSubset$X.3)
mean(gdpSubset$X.3)
rank = read.csv("./Week 4/gross_domestic_product_rank.csv");
head(rank,10)
rank$X.3
gdpSubset = rank[grep("^[0-9]+$",rank$Gross.domestic.product.2012, perl=TRUE,
value=FALSE),c("X","X.3","Gross.domestic.product.2012")] # find those obs from gdp where the ranking is from # 1 to 190
formatLevel <- function (x)   # function to format the level as it contains unwanted characters : , " "
{
gsub(",+","",gsub("^\\s+|\\s+$", "", x))
}
gdpSubset$X.3 = as.numeric(formatLevel(as.character(gdpSubset$X.3))) # Convert all of the factors into numeric.
names(gdpSubset)
gdpSubset$X.3
mean(gdpSubset$X.3)
summary(gdpSubset$X.3)
rank = read.csv("./Week 4/gross_domestic_product_rank.csv");
head(rank,10)
grep("United+",rank$X.2)
grep("United+",rank$X.2),2
rank$X.2
grep("Be+",rank$X.2)
grep("*United",rank$X.2)
grep("^United",rank$X.2)
grep("^United",rank$X.2)
rank[,c(5,10,36)]
rank[c(5,10,36),]
gdp = read.csv("./Week 4/gross_domestic_product_rank.csv");
edu = read.csv("./Week 4/educational_data.csv");
mergedData = merge(gdp,edu,by.x="X",by.y="CountryCode",all=FALSE)  # match eduSubset and gdpSubset based on 'CountryCode' & 'gdp' columns respectively; FALSE indicate that only
head(mergedData,20)
names(gdp)
names(edu)
edu$Special.Notes
mergedData[grep("June+",edu$Special.Notes)]$Special.Notes
mergedData[grep("June+",edu$Special.Notes),]$Special.Notes
mergedData[grep("June",edu$Special.Notes),]$Special.Notes
mergedData[grep("^June",edu$Special.Notes),]$Special.Notes
mergedData[grep("June*",edu$Special.Notes),]$Special.Notes
mergedData[grep("^Fiscal year end: June 30",edu$Special.Notes),]$Special.Notes
mergedData$Special.Notes
mergedData[grep("^Fiscal year end: June 30",edu$Special.Notes),]$Special.Notes
install.packages("quantmod")
library("quantmod", lib.loc="C:/Users/dormantroot/Documents/R/win-library/3.0")
library(quantmod)
amzn = getSymbols("AMZN", auto.assign=FALSE)
sampleTimes = index(amzn)
sampleTimes
grep("^2012",sampleTimes)
length(grep("^2012",sampleTimes))
dim(grep("^2012",sampleTimes))
length(grep("^2012",sampleTimes))
sampleTimes
sampleTimes[1]
weekdays(sampleTimes[1])
weekdays(sampleTimes)
samplesTimes[which(weekdays(sampleTimes) == "Monday",]
samplesTimes[which(weekdays(sampleTimes) == "Monday"]
samplesTimes(which(weekdays(sampleTimes) == "Monday")
samplesTimes(which(weekdays(sampleTimes)) == "Monday")
samplesTimes(which(weekdays(sampleTimes)) == "Monday")
sampleTimes(which(weekdays(sampleTimes)) == "Monday")
sampleTimes(which(weekdays(sampleTimes) == "Monday"))
is.element("Monday",weekdays(sampleTimes))
table(is.element("Monday",weekdays(sampleTimes)))
sampleTimes
grep("Monday",weekdays(sampleTimes)))
grep("Monday",weekdays(sampleTimes))
samplesTimes(grep("^2012",sampleTimes))
sampleTimes(grep("^2012",sampleTimes))
sampleTimes[grep("^2012",sampleTimes)]
grep("Monday",weekdays(sampleTimes[grep("^2012",sampleTimes)])) # values collected in 2012, specifically on a Monday
table(grep("Monday",weekdays(sampleTimes[grep("^2012",sampleTimes)]))) # number of values collected in 2012, specifically on a Monday
length(grep("Monday",weekdays(sampleTimes[grep("^2012",sampleTimes)]))) # number of values collected in 2012, specifically on a Monday
mtcars   # the standard R dataset
mtcars$carname = rownames(mtcars) # add a new column 'carname' to the original dataset 'mtcars' with the unique car values
carMelt = melt(mtcars, id=c("carname","gear","cyl"), measure.vars=c("mpg","hp")) # create a new melted dataset with only 3 columns (carname, gear & cyl)
library("reshape2", lib.loc="C:/Users/dormantroot/Documents/R/win-library/3.0")
carMelt = melt(mtcars, id=c("carname","gear","cyl"), measure.vars=c("mpg","hp")) # create a new melted dataset with only 3 columns (carname, gear & cyl)
# that contain values "mpg" & "hp"
carMelt
